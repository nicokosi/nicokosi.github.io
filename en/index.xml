<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nicokosi&#39;s blog</title>
    <link>https://nicokosi.github.io/en/index.xml</link>
    <description>Recent content on Nicokosi&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/nicokosi&#34;&gt;Nicolas Kosinski&lt;/a&gt; 2016</copyright>
    <lastBuildDate>Tue, 27 Sep 2016 00:00:00 +0100</lastBuildDate>
    <atom:link href="https://nicokosi.github.io/en/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Let&#39;s play with pattern matching in Haskell</title>
      <link>https://nicokosi.github.io/en/post/haskell-pattern-matching/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nicokosi.github.io/en/post/haskell-pattern-matching/</guid>
      <description>

&lt;p&gt;Let&amp;rsquo;s discover Haskell and pattern matching via basic examples similar to &lt;a href=&#34;https://nicokosi.github.io/scala-pattern-matching-en.html&#34;&gt;&amp;ldquo;Let&amp;rsquo;s play with pattern matching in Scala&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;step-1-create-an-enumeration&#34;&gt;Step #1: create an enumeration&lt;/h2&gt;

&lt;p&gt;We can create an enumeration that represent the four suites in French playing cards:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data CardSuite = Club | Diamond | Heart | Spade
  deriving (Eq, Enum, Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have just created our own &lt;em&gt;data type&lt;/em&gt; which:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;has four constructors (&lt;em&gt;value constructors&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;inherits from Haskell&amp;rsquo;s base types:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Eq&lt;/code&gt; in order to know if two values are equal or not&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enum&lt;/code&gt; so that all values are known and ordered (&lt;em&gt;sequentially ordered types&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Show&lt;/code&gt; so that we can have a string representation for debugging/troubleshooting&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then use &lt;code&gt;ghci&lt;/code&gt; (&lt;em&gt;Glascow Haskell Compiler Interactive environment&lt;/em&gt;), the Haskell REPL, to illustrate how we can use this enumeration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; Heart == Heart
True
*Main&amp;gt; Heart &amp;lt; Spade
True
*Main&amp;gt; succ Heart
Spade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;pattern-matching-examples&#34;&gt;Pattern matching examples&lt;/h2&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example #1&lt;/h3&gt;

&lt;p&gt;The following function returns the Unicode symbol for a given card suite:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;symbol :: CardSuite -&amp;gt; String
symbol cardSuite =
  case cardSuite of
    Club -&amp;gt; &amp;quot;â™£&amp;quot;
    Diamond -&amp;gt;&amp;quot;â™¦&amp;quot;
    Heart -&amp;gt; &amp;quot;â™¥&amp;quot;
    Spade -&amp;gt; &amp;quot;â™ &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s evaluate it :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; putStrLn $ symbol $ Heart
â™¥
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;$&lt;/code&gt; operator allows is a way chain function calls, omitting to use nested parenthesis (&lt;code&gt;putStrLn(symbol(Heart))&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;putStrLn&lt;/code&gt; standard function can display Unicode characters, whereas the standard function &lt;code&gt;show&lt;/code&gt; only displays ASCII characters. ðŸ˜Ž&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
Morevover, the Haskell compiler can detect a non-exhaustive pattern matching. For instance, the following code :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;symbol :: CardSuite -&amp;gt; String
symbol cardSuite =
  case cardSuite of
    Club -&amp;gt; &amp;quot;â™£&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;generates a compile-time warning :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative:
        Patterns not matched:
            Diamond
            Heart
            Spade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the following evaluation triggers an error :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; symbol Diamond
&amp;quot;*** Exception: test-en.hs:(13,3)-(14,15): Non-exhaustive patterns in case
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;example-2-share-expression-with-a-where-block&#34;&gt;Example #2, share expression with a &amp;lsquo;where&amp;rsquo; block&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s implement a &lt;code&gt;color&lt;/code&gt; function that returns &amp;ldquo;red&amp;rdquo; or &amp;ldquo;black&amp;rdquo; depending on the input card suite:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;color :: CardSuite -&amp;gt; String
color cardSuite =
  case cardSuite of
    Club -&amp;gt; black
    Diamond -&amp;gt; red
    Heart -&amp;gt; red
    Spade -&amp;gt; black
    where
      red = &amp;quot;red&amp;quot;
      black = &amp;quot;black&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s evaluate it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*Main&amp;gt; color Heart
&amp;quot;red&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;where&lt;/code&gt; keyword is used there to share some expressions.
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;example-3-destructuring&#34;&gt;Example #3: destructuring&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to define our custom type &lt;code&gt;Card&lt;/code&gt; that combines a rank (1, 2, 3, &amp;hellip;, Jack, Queen, King) and a suite:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Rank =
  R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | Jack | Queen | King
  deriving (Eq, Ord, Enum, Show)

data Card = Card {
  rank :: Rank,
  suite :: CardSuite
} deriving (Eq, Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Card&lt;/code&gt; type uses the &lt;em&gt;record&lt;/em&gt; syntax that allows to name fields.&lt;/p&gt;

&lt;p&gt;We can then use pattern matching in order to de-structure a card, filtering some fields.
For instance, the following function determines if two cards have the same suite:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;sameSuite :: (Card, Card) -&amp;gt; Bool
sameSuite ((Card _ suite1), (Card _ suite2)) =
  suite1 == suite2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Call examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*Main&amp;gt; :{
*Main| sameSuite (
*Main|        Card {rank=R1, suite=Diamond},
*Main|        Card {rank=R1, suite=Heart} )
*Main| :}
False
*Main&amp;gt; :{
*Main| sameSuite (
*Main|      Card {rank=Jack, suite=Heart},
*Main|      Card {rank=R1, suite=Diamond} )
*Main| :}
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Card ranks, that are not needed by our function, have been filtered using the &lt;em&gt;wild-card&lt;/em&gt; symbol (&lt;code&gt;_&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all, folks! ðŸ¤“&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s play with pattern matching in Scala</title>
      <link>https://nicokosi.github.io/en/post/scala-pattern-matching/</link>
      <pubDate>Wed, 14 Sep 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nicokosi.github.io/en/post/scala-pattern-matching/</guid>
      <description>

&lt;p&gt;Pattern matching is a powerful technique for filtering and testing variables. This article aims at illustrating pattern matching in Scala using a simple example.
Let&amp;rsquo;s say we want to return the color (red or black) of a playing card.&lt;/p&gt;

&lt;p&gt;Notes: The code below &amp;ldquo;shows&amp;rdquo; the console output using comments (ex: &lt;code&gt;&amp;quot;foo&amp;quot; // foo&lt;/code&gt;). I have used a &lt;a href=&#34;https://confluence.jetbrains.com/display/IntelliJIDEA/Working+with+Scala+Worksheet&#34;&gt;IntelliJ IDEA worksheet&lt;/a&gt; but the standard Scala console can also be used (REPL FTW!)&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;step-1-let-s-create-a-simple-class&#34;&gt;Step #1: let&amp;rsquo;s create a simple class&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a immutable class for the &amp;ldquo;club&amp;rdquo; suite:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Club {
  val symbol = &amp;quot;â™£&amp;quot;
  val label = &amp;quot;club&amp;quot;
}

val club: Club = new Club()
club.symbol // â™£
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good. Instances can be compared by identity (reference) but not by value because we did not override the &lt;code&gt;equals&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;club.equals(club) // true
club == new Club // false
club.eq(new Club) // false
club.equals(new Club) // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; are also default ones:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;club // Club@1ac88f64
club.hashCode() // 1976061787
new Club().hashCode() // 1751431390
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;step-2-let-s-create-a-case-class&#34;&gt;Step #2: let&amp;rsquo;s create a case class&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;case class&lt;/code&gt; has two benefits:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;auto-implement &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; methods.&lt;/li&gt;
&lt;li&gt;enhance pattern matching capability via two methods: a &amp;ldquo;constructor&amp;rdquo; method, &lt;code&gt;apply&lt;/code&gt;, and a &amp;ldquo;de-constructor&amp;rdquo; method, &lt;code&gt;unapply&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class CardSuite(symbol: String, label: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; method is a kind of free constructor. By the way, we don&amp;rsquo;t need to use the &lt;code&gt;new&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;) // CardSuite(â™£,club)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; methods are also implemented for free:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;).symbol
CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;) == CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;) // true
CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;).equals(CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;)) // true
CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;).eq(CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;)) // false
CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;).hashCode() // 1302714609
CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;).hashCode() // 1302714609
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;bonus-step-use-an-enumeration&#34;&gt;&amp;ldquo;Bonus&amp;rdquo; step: use an enumeration&lt;/h2&gt;

&lt;p&gt;Since there are four suites in French playing cards, we can create an enumeration. This is not directly related to our pattern matching example, but let&amp;rsquo;s do it, for fun and profit. ;-)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object CardSuites {
  val CLUB = CardSuite(&amp;quot;â™£&amp;quot;, &amp;quot;club&amp;quot;)
  val DIAMOND = CardSuite(&amp;quot;â™¦&amp;quot;, &amp;quot;diamond&amp;quot;)
  val HEART = CardSuite(&amp;quot;â™¥&amp;quot;, &amp;quot;heart&amp;quot;)
  val SPADE = CardSuite(&amp;quot;â™ &amp;quot;, &amp;quot;spade&amp;quot;)
  def values() = List(DIAMOND, HEART, SPADE, CLUB)
}
CardSuites.CLUB != CardSuites.DIAMOND // true
CardSuites.values // List(CardSuite(â™¦,diamond), CardSuite(â™¥,heart), CardSuite(â™ ,spade), CardSuite(â™£,club))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;last-step-let-s-use-pattern-matching&#34;&gt;Last step: let&amp;rsquo;s use pattern matching!&lt;/h2&gt;

&lt;h3 id=&#34;first-example&#34;&gt;First example&lt;/h3&gt;

&lt;p&gt;Here is a first pattern matching example, used in a function that returns the color of a suite card:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def justColor(cardSuite: CardSuite): String = cardSuite match {
  case CardSuites.CLUB | CardSuites.SPADE =&amp;gt; &amp;quot;black&amp;quot;
  case CardSuites.DIAMOND | CardSuites.HEART =&amp;gt; &amp;quot;red&amp;quot;
  case _ =&amp;gt; &amp;quot;none&amp;quot;
}

justColor(CardSuites.SPADE) // black
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example demonstrates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;|&lt;/code&gt; notation (&lt;em&gt;disjunction&lt;/em&gt;) that can be used to group several cases;&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;_&lt;/code&gt; notation (&lt;em&gt;wildcard&lt;/em&gt;) for &amp;ldquo;other cases&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;second-example&#34;&gt;Second example&lt;/h3&gt;

&lt;p&gt;Here is a second example to demonstrate field filtering, also known as &amp;ldquo;de-structuring&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def describeColor(cardSuite: CardSuite): String = cardSuite match {
  case CardSuite(_, label) =&amp;gt; s&amp;quot;$label is ${justColor(cardSuite)}&amp;quot;
}

describeColor(CardSuites.SPADE) // spade is black
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We only keep the suite label using the &lt;code&gt;unapply&lt;/code&gt; method of our case class.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all folks! ðŸ¤“&lt;/p&gt;

&lt;p&gt;PS: Thanks to JÃ©rÃ´me Prudent for the Scala tips and for the review. JÃ©rÃ´me contributes to the &lt;a href=&#34;http://www.arolla.fr/blog&#34;&gt;Arolla blog&lt;/a&gt; (&lt;a href=&#34;http://www.arolla.fr/blog/author/jerome-prudent/&#34;&gt;direct link to his posts&lt;/a&gt;).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>