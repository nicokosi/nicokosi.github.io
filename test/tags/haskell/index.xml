<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Le blog de Nicokosi</title>
    <link>https://nicokosi.github.io/test/tags/haskell/index.xml</link>
    <description>Recent content on Le blog de Nicokosi</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/nicokosi&#34;&gt;Nicolas Kosinski&lt;/a&gt; 2016</copyright>
    <atom:link href="https://nicokosi.github.io/test/tags/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Jouons avec le pattern matching en Haskell</title>
      <link>https://nicokosi.github.io/test/post/haskell-pattern-matching/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nicokosi.github.io/test/post/haskell-pattern-matching/</guid>
      <description>

&lt;p&gt;D√©couvrons le pattern matching en Haskell en reprenant l&amp;rsquo;exemple des cartes √† jouer utilis√© dans l&amp;rsquo;article &lt;a href=&#34;https://nicokosi.github.io/scala-pattern-matching.html&#34;&gt;&amp;ldquo;Jouons avec le pattern matching en Scala&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;pr√©ambule-cr√©ation-d-une-√©num√©ration&#34;&gt;Pr√©ambule : cr√©ation d&amp;rsquo;une √©num√©ration&lt;/h2&gt;

&lt;p&gt;Codons notre √©num√©ration correspondant √† nos quatre enseignes (carreau, c≈ìur, pique et tr√®fle) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Enseigne = Carreau | Coeur | Pique | Tr√®fle
  deriving (Eq, Enum, Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous venons de cr√©er notre propre type (&lt;em&gt;data type&lt;/em&gt;) qui :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a quatre constructeurs (&lt;em&gt;value constructors&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;h√©rite des classes de base :

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Eq&lt;/code&gt; pour impl√©menter l&amp;rsquo;√©galit√© entre deux valeurs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enum&lt;/code&gt; pour que les valeurs sont finies et ordonn√©es (&lt;em&gt;sequentially ordered types&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Show&lt;/code&gt; pour avoir une repr√©sentation sous forme de cha√Æne de caract√®res, ce qui peut √™tre utile pour d√©bugguer ou pour √©valuer interactivement du code via le REPL.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Utilisons maintenant &lt;code&gt;ghci&lt;/code&gt; (&lt;em&gt;Glascow Haskell Compiler Interactive environment&lt;/em&gt;), le REPL d&amp;rsquo;Haskell, pour interagir avec cette √©num√©ration :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; Coeur == Coeur
True
*Main&amp;gt; succ Coeur
Pique
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;exemples-de-pattern-matching&#34;&gt;Exemples de pattern matching&lt;/h2&gt;

&lt;h3 id=&#34;premier-exemple-basique&#34;&gt;Premier exemple basique&lt;/h3&gt;

&lt;p&gt;La fonction suivante retourne le symbole d&amp;rsquo;une enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;symbole :: Enseigne -&amp;gt; String
symbole enseigne =
  case enseigne of
    Carreau -&amp;gt;&amp;quot;‚ô¶&amp;quot;
    Coeur -&amp;gt; &amp;quot;‚ô•&amp;quot;
    Pique -&amp;gt; &amp;quot;‚ô†&amp;quot;
    Tr√®fle -&amp;gt; &amp;quot;‚ô£&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemple d&amp;rsquo;appel :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; putStrLn $ symbole $ Coeur
‚ô•
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notons que :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;op√©rateur &lt;code&gt;$&lt;/code&gt; nous permet de cha√Æner nos fonctions, plut√¥t que de les imbriquer dans des parenth√®ses (&lt;code&gt;putStrLn(symbole(Coeur))&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;la fonction &lt;code&gt;putStrLn&lt;/code&gt; permet d&amp;rsquo;afficher des caract√®res Unicode, √† l&amp;rsquo;inverse de la fonction standard &lt;code&gt;show&lt;/code&gt; qui ne retourne que des cha√Ænes ASCII. üòé&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
Remarque : le compilateur sait d√©tecter un pattern matching non exhaustif. Par exemple, le code suivant :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;symbole :: Enseigne -&amp;gt; String
symbole enseigne = case enseigne of
    Carreau -&amp;gt;&amp;quot;‚ô¶&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;g√©n√®re un avertissement de compilation :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative:
        Patterns not matched:
            Coeur
            Pique
            Tr√®fle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et l&amp;rsquo;appel de cette fonction g√©n√©re une exception :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; symbole Coeur
&amp;quot;*** Exception: test.hs:(5,20)-(6,17): Non-exhaustive patterns in case
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;deuxi√®me-exemple-partage-d-expression-via-un-bloc-where&#34;&gt;Deuxi√®me exemple, partage d&amp;rsquo;expression via un bloc &amp;lsquo;where&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;Autre exemple, impl√©mentons une fonction &lt;code&gt;couleur&lt;/code&gt; qui retourne la couleur d&amp;rsquo;une enseigne (cha√Æne de caract√®res &amp;ldquo;rouge&amp;rdquo; ou &amp;ldquo;noir&amp;rdquo;) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;couleur :: Enseigne -&amp;gt; String
couleur enseigne = case enseigne of
    Carreau -&amp;gt; rouge
    Coeur -&amp;gt; rouge
    Pique -&amp;gt; noir
    Tr√®fle -&amp;gt; noir
    where
      rouge = &amp;quot;rouge&amp;quot;
      noir = &amp;quot;noir&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemple d&amp;rsquo;appel :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*Main&amp;gt; couleur(Coeur)
&amp;quot;rouge&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous avons ici utilis√© le mot-cl√© &lt;code&gt;where&lt;/code&gt; qui nous permet de partager des expressions.
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;troisi√®me-exemple-d√©structuration&#34;&gt;Troisi√®me exemple, d√©structuration&lt;/h3&gt;

&lt;p&gt;D√©finissons notre propre type &lt;code&gt;Carte&lt;/code&gt; combinant un rang (1, 2, 3, &amp;hellip;, valet, dame, roi) et une enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Rang =
  R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | Valet | Dame | Roi
  deriving (Eq, Ord, Enum, Show)

data Carte = Carte {
  rang :: Rang,
  enseigne :: Enseigne
} deriving (Eq, Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le type &lt;code&gt;Carte&lt;/code&gt; utilise la syntaxe &lt;em&gt;record&lt;/em&gt; permettant de nommer les champs.&lt;/p&gt;

&lt;p&gt;Nous pouvons ainsi utiliser le pattern matching pour &amp;ldquo;d√©structurer&amp;rdquo; une carte en filtrant les champs. Par exemple, la fonction suivante permet de d√©terminer si deux cartes, associ√©es par un &lt;em&gt;tuple&lt;/em&gt;, sont de m√™me enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;m√™meEnseigne :: (Carte, Carte) -&amp;gt; Bool
m√™meEnseigne ((Carte _ enseigne1), (Carte _ enseigne2)) =
  enseigne1 == enseigne2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemples d&amp;rsquo;appel :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*Main&amp;gt; :{
*Main| m√™meEnseigne (
*Main|     Carte {rang=R1, enseigne=Carreau},
*Main|     Carte {rang=R1, enseigne=Coeur} )
*Main| :}
False
*Main&amp;gt; :{
*Main| m√™meEnseigne (
*Main|     Carte {rang=Valet, enseigne=Coeur},
*Main|     Carte {rang=R1, enseigne=Coeur} )
*Main| :}
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les rangs, que l&amp;rsquo;on n&amp;rsquo;utilise pas dans la fonction, ont √©t√© filtr√©s via le caract√®re &lt;em&gt;wild-card&lt;/em&gt; (&lt;code&gt;_&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Et voil√† ! ü§ì&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>