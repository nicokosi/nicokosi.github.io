<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Le blog de Nicokosi</title>
    <link>https://nicokosi.github.io/test/index.xml</link>
    <description>Recent content on Le blog de Nicokosi</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/nicokosi&#34;&gt;Nicolas Kosinski&lt;/a&gt; 2016</copyright>
    <lastBuildDate>Tue, 27 Sep 2016 00:00:00 +0100</lastBuildDate>
    <atom:link href="https://nicokosi.github.io/test/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Jouons avec le pattern matching en Haskell</title>
      <link>https://nicokosi.github.io/test/post/haskell-pattern-matching/</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nicokosi.github.io/test/post/haskell-pattern-matching/</guid>
      <description>

&lt;p&gt;D√©couvrons le pattern matching en Haskell en reprenant l&amp;rsquo;exemple des cartes √† jouer utilis√© dans l&amp;rsquo;article &lt;a href=&#34;https://nicokosi.github.io/scala-pattern-matching.html&#34;&gt;&amp;ldquo;Jouons avec le pattern matching en Scala&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;pr√©ambule-cr√©ation-d-une-√©num√©ration&#34;&gt;Pr√©ambule : cr√©ation d&amp;rsquo;une √©num√©ration&lt;/h2&gt;

&lt;p&gt;Codons notre √©num√©ration correspondant √† nos quatre enseignes (carreau, c≈ìur, pique et tr√®fle) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Enseigne = Carreau | Coeur | Pique | Tr√®fle
  deriving (Eq, Enum, Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous venons de cr√©er notre propre type (&lt;em&gt;data type&lt;/em&gt;) qui :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a quatre constructeurs (&lt;em&gt;value constructors&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;h√©rite des classes de base :

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Eq&lt;/code&gt; pour impl√©menter l&amp;rsquo;√©galit√© entre deux valeurs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enum&lt;/code&gt; pour que les valeurs sont finies et ordonn√©es (&lt;em&gt;sequentially ordered types&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Show&lt;/code&gt; pour avoir une repr√©sentation sous forme de cha√Æne de caract√®res, ce qui peut √™tre utile pour d√©bugguer ou pour √©valuer interactivement du code via le REPL.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Utilisons maintenant &lt;code&gt;ghci&lt;/code&gt; (&lt;em&gt;Glascow Haskell Compiler Interactive environment&lt;/em&gt;), le REPL d&amp;rsquo;Haskell, pour interagir avec cette √©num√©ration :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; Coeur == Coeur
True
*Main&amp;gt; succ Coeur
Pique
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;exemples-de-pattern-matching&#34;&gt;Exemples de pattern matching&lt;/h2&gt;

&lt;h3 id=&#34;premier-exemple-basique&#34;&gt;Premier exemple basique&lt;/h3&gt;

&lt;p&gt;La fonction suivante retourne le symbole d&amp;rsquo;une enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;symbole :: Enseigne -&amp;gt; String
symbole enseigne =
  case enseigne of
    Carreau -&amp;gt;&amp;quot;‚ô¶&amp;quot;
    Coeur -&amp;gt; &amp;quot;‚ô•&amp;quot;
    Pique -&amp;gt; &amp;quot;‚ô†&amp;quot;
    Tr√®fle -&amp;gt; &amp;quot;‚ô£&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemple d&amp;rsquo;appel :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; putStrLn $ symbole $ Coeur
‚ô•
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notons que :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L&amp;rsquo;op√©rateur &lt;code&gt;$&lt;/code&gt; nous permet de cha√Æner nos fonctions, plut√¥t que de les imbriquer dans des parenth√®ses (&lt;code&gt;putStrLn(symbole(Coeur))&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;la fonction &lt;code&gt;putStrLn&lt;/code&gt; permet d&amp;rsquo;afficher des caract√®res Unicode, √† l&amp;rsquo;inverse de la fonction standard &lt;code&gt;show&lt;/code&gt; qui ne retourne que des cha√Ænes ASCII. üòé&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt;
Remarque : le compilateur sait d√©tecter un pattern matching non exhaustif. Par exemple, le code suivant :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;symbole :: Enseigne -&amp;gt; String
symbole enseigne = case enseigne of
    Carreau -&amp;gt;&amp;quot;‚ô¶&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;g√©n√®re un avertissement de compilation :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative:
        Patterns not matched:
            Coeur
            Pique
            Tr√®fle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et l&amp;rsquo;appel de cette fonction g√©n√©re une exception :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;*Main&amp;gt; symbole Coeur
&amp;quot;*** Exception: test.hs:(5,20)-(6,17): Non-exhaustive patterns in case
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;deuxi√®me-exemple-partage-d-expression-via-un-bloc-where&#34;&gt;Deuxi√®me exemple, partage d&amp;rsquo;expression via un bloc &amp;lsquo;where&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;Autre exemple, impl√©mentons une fonction &lt;code&gt;couleur&lt;/code&gt; qui retourne la couleur d&amp;rsquo;une enseigne (cha√Æne de caract√®res &amp;ldquo;rouge&amp;rdquo; ou &amp;ldquo;noir&amp;rdquo;) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;couleur :: Enseigne -&amp;gt; String
couleur enseigne = case enseigne of
    Carreau -&amp;gt; rouge
    Coeur -&amp;gt; rouge
    Pique -&amp;gt; noir
    Tr√®fle -&amp;gt; noir
    where
      rouge = &amp;quot;rouge&amp;quot;
      noir = &amp;quot;noir&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemple d&amp;rsquo;appel :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*Main&amp;gt; couleur(Coeur)
&amp;quot;rouge&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous avons ici utilis√© le mot-cl√© &lt;code&gt;where&lt;/code&gt; qui nous permet de partager des expressions.
&lt;br/&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;troisi√®me-exemple-d√©structuration&#34;&gt;Troisi√®me exemple, d√©structuration&lt;/h3&gt;

&lt;p&gt;D√©finissons notre propre type &lt;code&gt;Carte&lt;/code&gt; combinant un rang (1, 2, 3, &amp;hellip;, valet, dame, roi) et une enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Rang =
  R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | Valet | Dame | Roi
  deriving (Eq, Ord, Enum, Show)

data Carte = Carte {
  rang :: Rang,
  enseigne :: Enseigne
} deriving (Eq, Show)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le type &lt;code&gt;Carte&lt;/code&gt; utilise la syntaxe &lt;em&gt;record&lt;/em&gt; permettant de nommer les champs.&lt;/p&gt;

&lt;p&gt;Nous pouvons ainsi utiliser le pattern matching pour &amp;ldquo;d√©structurer&amp;rdquo; une carte en filtrant les champs. Par exemple, la fonction suivante permet de d√©terminer si deux cartes, associ√©es par un &lt;em&gt;tuple&lt;/em&gt;, sont de m√™me enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;m√™meEnseigne :: (Carte, Carte) -&amp;gt; Bool
m√™meEnseigne ((Carte _ enseigne1), (Carte _ enseigne2)) =
  enseigne1 == enseigne2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemples d&amp;rsquo;appel :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*Main&amp;gt; :{
*Main| m√™meEnseigne (
*Main|     Carte {rang=R1, enseigne=Carreau},
*Main|     Carte {rang=R1, enseigne=Coeur} )
*Main| :}
False
*Main&amp;gt; :{
*Main| m√™meEnseigne (
*Main|     Carte {rang=Valet, enseigne=Coeur},
*Main|     Carte {rang=R1, enseigne=Coeur} )
*Main| :}
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Les rangs, que l&amp;rsquo;on n&amp;rsquo;utilise pas dans la fonction, ont √©t√© filtr√©s via le caract√®re &lt;em&gt;wild-card&lt;/em&gt; (&lt;code&gt;_&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Et voil√† ! ü§ì&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jouons avec le pattern matching en Scala</title>
      <link>https://nicokosi.github.io/test/post/scala-pattern-matching/</link>
      <pubDate>Wed, 14 Sep 2016 00:00:00 +0100</pubDate>
      
      <guid>https://nicokosi.github.io/test/post/scala-pattern-matching/</guid>
      <description>

&lt;p&gt;Le pattern matching est une technique puissante permettant de filtrer et de tester la valeur de variables. Le but de cet article est d‚Äôillustrer par l&amp;rsquo;exemple le pattern matching en Scala.&lt;/p&gt;

&lt;p&gt;Supposons que nous voulions cr√©er une fonction retournant la couleur (noir / rouge) d&amp;rsquo;une enseigne d&amp;rsquo;une carte √† jouer (les quatre enseignes du jeu fran√ßais √©tant : tr√®fle, c≈ìur, carreau et pique).&lt;/p&gt;

&lt;p&gt;Notes : dans le code ci-dessous, les commentaires se trouvant √† la fin de chaque ligne correspondent √† la sortie standard de la console ; j&amp;rsquo;ai utilis√© un &lt;a href=&#34;https://confluence.jetbrains.com/display/IntelliJIDEA/Working+with+Scala+Worksheet&#34;&gt;worksheet IntelliJ IDEA&lt;/a&gt; pour coder interactivement cet exemple, mais on peut bien s√ªr utiliser la console Scala.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;1√®re-√©tape-cr√©ation-d-une-simple-classe&#34;&gt;1√®re √©tape : cr√©ation d&amp;rsquo;une simple classe&lt;/h2&gt;

&lt;p&gt;Commen√ßons par cr√©er une classe immuable repr√©sentant l&amp;rsquo;enseigne &amp;ldquo;tr√®fle&amp;rdquo; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;class Tr√®fle {
   val symbole = &amp;quot;‚ô£&amp;quot;
   val libell√© = &amp;quot;tr√®fle&amp;quot;
}

val tr√®fle: Tr√®fle = new Tr√®fle()
tr√®fle.symbole // ‚ô£
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notons que cette classe permet de comparer des objets par identit√© (r√©f√©rence) et non par valeur car on ne surcharge pas la m√©thode &lt;code&gt;equals&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;tr√®fle.equals(tr√®fle) // true
tr√®fle == new Tr√®fle // false
tr√®fle.eq(new Tr√®fle) // false
tr√®fle.equals(new Tr√®fle) // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;De m√™me, les m√©thodes &lt;code&gt;hashCode&lt;/code&gt;, &lt;code&gt;toString&lt;/code&gt; sont celles par d√©faut :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;tr√®fle // Tr√®fle@1ac88f64
tr√®fle.hashCode() // 123717365
new Tr√®fle().hashCode() // 1323753063
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;2√®me-√©tape-cr√©ation-d-une-case-class&#34;&gt;2√®me √©tape : cr√©ation d&amp;rsquo;une case class&lt;/h2&gt;

&lt;p&gt;La cr√©ation d&amp;rsquo;une &lt;code&gt;case class&lt;/code&gt; permet :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;d&amp;rsquo;auto-impl√©menter les m√©thodes &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; et &lt;code&gt;toString&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;de b√©n√©ficier de deux m√©thodes utiles au pattern matching : un &amp;ldquo;constructeur&amp;rdquo;, la m√©thode &lt;code&gt;apply&lt;/code&gt;, et un &amp;ldquo;d√©-constructeur&amp;rdquo;, la m√©thode &lt;code&gt;unapply&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;case class Enseigne(symbole: String, libell√©: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous avons un constructeur &amp;ldquo;gratuit&amp;rdquo;, la m√©thode &lt;code&gt;apply&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;) // Enseigne(‚ô£,tr√®fle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous avons √©galement une impl√©mentation &amp;ldquo;gratuite&amp;rdquo;, bas√©e sur les champs, des m√©thodes &lt;code&gt;equals&lt;/code&gt;, &lt;code&gt;hashCode&lt;/code&gt; et &lt;code&gt;toString&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;).symbole // ‚ô£
Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;) == Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;) // true
Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;).equals(Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;)) // true
Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;).eq(Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;)) // false
Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;).hashCode() // 841520215
Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;).hashCode() // 841520215
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;etape-bonus-cr√©ation-d-une-√©num√©ration&#34;&gt;Etape &amp;ldquo;bonus&amp;rdquo; : cr√©ation d&amp;rsquo;une √©num√©ration&lt;/h2&gt;

&lt;p&gt;Puisque nous avons quatre enseignes, nous pouvons cr√©er une √©num√©ration. Ca ne servira pas directement √† impl√©menter notre exemple final mais l&amp;rsquo;exemple s&amp;rsquo;y pr√™te bien.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Enseignes {
  val TREFLE = Enseigne(&amp;quot;‚ô£&amp;quot;, &amp;quot;tr√®fle&amp;quot;)
  val CARREAU = Enseigne(&amp;quot;‚ô¶&amp;quot;, &amp;quot;carreau&amp;quot;)
  val COEUR = Enseigne(&amp;quot;‚ô•&amp;quot;, &amp;quot;coeur&amp;quot;)
  val PIQUE = Enseigne(&amp;quot;‚ô†&amp;quot;, &amp;quot;pique&amp;quot;)
  def values() = List(CARREAU, COEUR, PIQUE, TREFLE)
}
Enseignes.TREFLE != Enseignes.CARREAU // true
Enseignes.values // List[Enseigne] = List(Enseigne(‚ô¶,carreau), Enseigne(‚ô•,coeur), Enseigne(‚ô†,pique), Enseigne(‚ô£,tr√®fle))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;derni√®re-√©tape-pattern-matchons&#34;&gt;Derni√®re √©tape : pattern matchons !&lt;/h2&gt;

&lt;h3 id=&#34;premier-exemple&#34;&gt;Premier exemple&lt;/h3&gt;

&lt;p&gt;Un premier exemple de pattern matching, utilis√© dans une fonction qui retourne la couleur de l&amp;rsquo;enseigne :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def indiquerJusteLaCouleur(cardSuite: Enseigne): String = cardSuite match {
  case Enseignes.TREFLE | Enseignes.PIQUE =&amp;gt; &amp;quot;noir&amp;quot;
  case Enseignes.CARREAU | Enseignes.COEUR =&amp;gt; &amp;quot;rouge&amp;quot;
  case _ =&amp;gt; &amp;quot;aucune&amp;quot;
}

indiquerJusteLaCouleur(Enseignes.PIQUE) // noir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ce premier exemple met en avant :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la notation &lt;code&gt;|&lt;/code&gt; (&lt;em&gt;disjunction&lt;/em&gt;) permettant de regrouper plusieurs cas ;&lt;/li&gt;
&lt;li&gt;la notation &lt;code&gt;_&lt;/code&gt; (&lt;em&gt;wildcard&lt;/em&gt;) pour g√©rer les autres cas.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deuxi√®me-exemple&#34;&gt;Deuxi√®me exemple&lt;/h3&gt;

&lt;p&gt;Voici un deuxi√®me exemple montrant comment r√©cup√©rer s√©lectivement certains champs (ici, le libell√© de l&amp;rsquo;enseigne) en &amp;ldquo;d√©-structurant&amp;rdquo; notre instance de &lt;code&gt;case class&lt;/code&gt;, via la m√©thode &lt;code&gt;unapply&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def d√©crireLaCouleur(enseigne: Enseigne): String = enseigne match {
  case Enseigne(_, libell√©) =&amp;gt; s&amp;quot;$libell√© is ${indiquerJusteLaCouleur(enseigne)}&amp;quot;
}

d√©crireLaCouleur(Enseignes.PIQUE) // pique est noir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Et voil√† ! ü§ì&lt;/p&gt;

&lt;p&gt;PS : merci √† J√©r√¥me Prudent pour ses tuyaux en Scala et ses avis √©clair√©s.
J√©r√¥me est contributeur au &lt;a href=&#34;http://www.arolla.fr/blog&#34;&gt;blog d&amp;rsquo;Arolla&lt;/a&gt; (&lt;a href=&#34;http://www.arolla.fr/blog/author/jerome-prudent/&#34;&gt;lien direct vers ses articles&lt;/a&gt;).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Versionner sa configuration syst√®me via des &#39;dotfiles&#39;</title>
      <link>https://nicokosi.github.io/test/post/dotfiles/</link>
      <pubDate>Thu, 18 Aug 2016 08:18:20 +0200</pubDate>
      
      <guid>https://nicokosi.github.io/test/post/dotfiles/</guid>
      <description>

&lt;h2 id=&#34;introduction-la-puissance-du-shell-avec-ou-sans-ma√Ætrise&#34;&gt;Introduction : la puissance du shell, avec ou sans ma√Ætrise ?&lt;/h2&gt;

&lt;p&gt;Cela fait environ deux ans que je d√©veloppe sur un poste &amp;ldquo;*nix&amp;rdquo; (Linux et Mac) apr√®s avoir d√©velopp√© de nombreuses ann√©es sur un poste Windows. La puissance du shell est ind√©niable : combiner des lignes de commandes simples, b√©n√©ficier de l&amp;rsquo;historique des commandes lanc√©es, etc. Pourquoi ne pas en profiter pour ma√Ætriser davantage son syst√®me en &lt;strong&gt;versionnant sa configuration&lt;/strong&gt; ?&lt;/p&gt;

&lt;h2 id=&#34;pr√©sentation-dotfiles-quezako&#34;&gt;Pr√©sentation : Dotfiles, quezako ?&lt;/h2&gt;

&lt;p&gt;Pour un syst√®me *nix (Linux, Mac, etc.), la configuration du shell et des applications est g√©n√©ralement centralis√©e dans les &amp;ldquo;dotfiles&amp;rdquo;, des fichiers / r√©pertoires dont le nom commence par un point (&amp;ldquo;dot&amp;rdquo; en anglais) et qui sont charg√©s en d√©but de session interactive ou au lancement d&amp;rsquo;applications. En utilisant un gestionnaire de sources et des liens symboliques, on peut facilement &lt;strong&gt;historiser&lt;/strong&gt; et &lt;strong&gt;synchroniser&lt;/strong&gt; l&amp;rsquo;√©volution de ces dotfiles afin de :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;personnaliser le syst√®me d&amp;rsquo;exploitation&lt;/strong&gt;  : options d&amp;rsquo;affichage (exemple : choisir de masquer automatiquement la barre des applications), audio, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;personnaliser son shell&lt;/strong&gt; :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;positionnement de variables d&amp;rsquo;environnement (exemples : &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;JAVA_HOME&lt;/code&gt;, &lt;code&gt;MVN_OPTIONS&lt;/code&gt; etc.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cr√©ation d&amp;rsquo;alias pour les commandes fr√©quemment utilis√©es et/ou dures √† m√©moriser (exemple : &lt;code&gt;alias mcist=&amp;quot;mvn clean install -DskipTests&amp;quot;&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;utilisation d&amp;rsquo;un shell &amp;ldquo;sur-vitamin√©&amp;rdquo; du type &lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;&gt;Oh My Zsh&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;g√©r√©r les applications install√©es&lt;/strong&gt;, √† condition d&amp;rsquo;utiliser un gestionnaire de paquets du type &lt;code&gt;homebrew&lt;/code&gt; (ou &lt;code&gt;apt&lt;/code&gt;, &lt;code&gt;OneGet&lt;/code&gt; etc.).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;comment-un-exemple-d-utilisation-du-mini-framework-holman-dotfiles&#34;&gt;Comment ? Un exemple d&amp;rsquo;utilisation du mini-framework &amp;ldquo;holman/dotfiles&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;On peut cr√©er son propre environnement ou bien utiliser un framework &amp;ldquo;dotfiles&amp;rdquo; pr√™t √† l&amp;rsquo;emploi car il existe de nombreux frameworks &amp;ldquo;dotfiles&amp;rdquo;, en voici une liste non-exhaustive : &lt;a href=&#34;https://dotfiles.github.io/&#34;&gt;https://dotfiles.github.io/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;J&amp;rsquo;ai pour ma part utilis√© &lt;a href=&#34;https://github.com/holman/dotfiles&#34;&gt;https://github.com/holman/dotfiles&lt;/a&gt; qui permet de g√©rer sa configuration &lt;code&gt;ZSH&lt;/code&gt; en proposant les fonctionnalit√©s suivantes :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;chargement automatique des fichiers nomm√©s &lt;code&gt;*.zsh&lt;/code&gt;, quel que soit leur r√©pertoire, favorisant ainsi une structure th√©matique. Par exemple, on peut distinguer la configuration du compilateur Java, dans le script &lt;code&gt;java/env.zsh&lt;/code&gt;, de la configuration du compilateur Go, dans le script &lt;code&gt;golang/env.zsh&lt;/code&gt;. Cette approche th√©matique remplace avantageusement l&amp;rsquo;utilisation d&amp;rsquo;un script monolithique.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cr√©ation de liens symboliques (&amp;ldquo;symlinks&amp;rdquo;) pointant vers les scripts de d√©marrage du shell (exemple : le fichier &lt;code&gt;$HOME/.zshrc&lt;/code&gt; pour le shell &lt;code&gt;ZSH&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apr√®s avoir &amp;ldquo;fork√©&amp;rdquo; &lt;a href=&#34;https://github.com/holman/dotfile&#34;&gt;https://github.com/holman/dotfiles&lt;/a&gt;, j&amp;rsquo;ai cr√©√© deux branches :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;une pour mon ordinateur personnel sous Mac : &lt;a href=&#34;https://github.com/nicokosi/dotfiles&#34;&gt;https://github.com/nicokosi/dotfiles&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;une autre pour mon ordinateur professionnel sous Linux : &lt;a href=&#34;https://github.com/nicokosi/dotfiles/tree/vidal&#34;&gt;https://github.com/nicokosi/dotfiles/tree/vidal&lt;/a&gt;
Ces branches me permettent d&amp;rsquo;avoir deux configurations bien distinctes m√™me si elles partagent certaines similitudes.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion-dotfiles-all-the-things&#34;&gt;Conclusion : &lt;em&gt;Dotfiles all the things&lt;/em&gt;!&lt;/h2&gt;

&lt;p&gt;M√™me si la mise en place et la maintenance de ses dotfiles prend du temps, l&amp;rsquo;investissement vaut le coup pour notamment :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;la r√©solution de probl√®mes&lt;/strong&gt; (exemples : identifier ce qui a √©t√© r√©cemment modifi√©, revenir √† une configuration pr√©c√©dente, etc.) ;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;synchroniser&lt;/strong&gt; des changements entre plusieurs machines (exemple : PC sous Linux au travail et Mac perso), chacune ayant  une configuration distincte ;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;partager&lt;/strong&gt; sa configuration avec d&amp;rsquo;autres d√©veloppeurs (&amp;ldquo;Voici le dernier r√©glage que j&amp;rsquo;ai utilis√© pour &amp;hellip;&amp;rdquo;).
:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS : merci √† Jean-Christophe Gay pour l&amp;rsquo;inspiration et les &amp;ldquo;bons tuyaux&amp;rdquo;. Voici son blog : &lt;a href=&#34;https://jeanchristophegay.com/&#34;&gt;https://jeanchristophegay.com/&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>